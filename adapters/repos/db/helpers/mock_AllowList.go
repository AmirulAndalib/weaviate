//                           _       _
// __      _____  __ ___   ___  __ _| |_ ___
// \ \ /\ / / _ \/ _` \ \ / / |/ _` | __/ _ \
//  \ V  V /  __/ (_| |\ V /| | (_| | ||  __/
//   \_/\_/ \___|\__,_| \_/ |_|\__,_|\__\___|
//
//  Copyright Â© 2016 - 2024 Weaviate B.V. All rights reserved.
//
//  CONTACT: hello@weaviate.io
//

// Code generated by mockery v2.43.2. DO NOT EDIT.

package helpers

import mock "github.com/stretchr/testify/mock"

// MockAllowList is an autogenerated mock type for the AllowList type
type MockAllowList struct {
	mock.Mock
}

type MockAllowList_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAllowList) EXPECT() *MockAllowList_Expecter {
	return &MockAllowList_Expecter{mock: &_m.Mock}
}

// Contains provides a mock function with given fields: id
func (_m *MockAllowList) Contains(id uint64) bool {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for Contains")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint64) bool); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockAllowList_Contains_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Contains'
type MockAllowList_Contains_Call struct {
	*mock.Call
}

// Contains is a helper method to define mock.On call
//   - id uint64
func (_e *MockAllowList_Expecter) Contains(id interface{}) *MockAllowList_Contains_Call {
	return &MockAllowList_Contains_Call{Call: _e.mock.On("Contains", id)}
}

func (_c *MockAllowList_Contains_Call) Run(run func(id uint64)) *MockAllowList_Contains_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *MockAllowList_Contains_Call) Return(_a0 bool) *MockAllowList_Contains_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAllowList_Contains_Call) RunAndReturn(run func(uint64) bool) *MockAllowList_Contains_Call {
	_c.Call.Return(run)
	return _c
}

// DeepCopy provides a mock function with given fields:
func (_m *MockAllowList) DeepCopy() AllowList {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DeepCopy")
	}

	var r0 AllowList
	if rf, ok := ret.Get(0).(func() AllowList); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(AllowList)
		}
	}

	return r0
}

// MockAllowList_DeepCopy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeepCopy'
type MockAllowList_DeepCopy_Call struct {
	*mock.Call
}

// DeepCopy is a helper method to define mock.On call
func (_e *MockAllowList_Expecter) DeepCopy() *MockAllowList_DeepCopy_Call {
	return &MockAllowList_DeepCopy_Call{Call: _e.mock.On("DeepCopy")}
}

func (_c *MockAllowList_DeepCopy_Call) Run(run func()) *MockAllowList_DeepCopy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockAllowList_DeepCopy_Call) Return(_a0 AllowList) *MockAllowList_DeepCopy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAllowList_DeepCopy_Call) RunAndReturn(run func() AllowList) *MockAllowList_DeepCopy_Call {
	_c.Call.Return(run)
	return _c
}

// Insert provides a mock function with given fields: ids
func (_m *MockAllowList) Insert(ids ...uint64) {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MockAllowList_Insert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Insert'
type MockAllowList_Insert_Call struct {
	*mock.Call
}

// Insert is a helper method to define mock.On call
//   - ids ...uint64
func (_e *MockAllowList_Expecter) Insert(ids ...interface{}) *MockAllowList_Insert_Call {
	return &MockAllowList_Insert_Call{Call: _e.mock.On("Insert",
		append([]interface{}{}, ids...)...)}
}

func (_c *MockAllowList_Insert_Call) Run(run func(ids ...uint64)) *MockAllowList_Insert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]uint64, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(uint64)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockAllowList_Insert_Call) Return() *MockAllowList_Insert_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockAllowList_Insert_Call) RunAndReturn(run func(...uint64)) *MockAllowList_Insert_Call {
	_c.Call.Return(run)
	return _c
}

// IsEmpty provides a mock function with given fields:
func (_m *MockAllowList) IsEmpty() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsEmpty")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockAllowList_IsEmpty_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsEmpty'
type MockAllowList_IsEmpty_Call struct {
	*mock.Call
}

// IsEmpty is a helper method to define mock.On call
func (_e *MockAllowList_Expecter) IsEmpty() *MockAllowList_IsEmpty_Call {
	return &MockAllowList_IsEmpty_Call{Call: _e.mock.On("IsEmpty")}
}

func (_c *MockAllowList_IsEmpty_Call) Run(run func()) *MockAllowList_IsEmpty_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockAllowList_IsEmpty_Call) Return(_a0 bool) *MockAllowList_IsEmpty_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAllowList_IsEmpty_Call) RunAndReturn(run func() bool) *MockAllowList_IsEmpty_Call {
	_c.Call.Return(run)
	return _c
}

// Iterator provides a mock function with given fields:
func (_m *MockAllowList) Iterator() AllowListIterator {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Iterator")
	}

	var r0 AllowListIterator
	if rf, ok := ret.Get(0).(func() AllowListIterator); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(AllowListIterator)
		}
	}

	return r0
}

// MockAllowList_Iterator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Iterator'
type MockAllowList_Iterator_Call struct {
	*mock.Call
}

// Iterator is a helper method to define mock.On call
func (_e *MockAllowList_Expecter) Iterator() *MockAllowList_Iterator_Call {
	return &MockAllowList_Iterator_Call{Call: _e.mock.On("Iterator")}
}

func (_c *MockAllowList_Iterator_Call) Run(run func()) *MockAllowList_Iterator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockAllowList_Iterator_Call) Return(_a0 AllowListIterator) *MockAllowList_Iterator_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAllowList_Iterator_Call) RunAndReturn(run func() AllowListIterator) *MockAllowList_Iterator_Call {
	_c.Call.Return(run)
	return _c
}

// Len provides a mock function with given fields:
func (_m *MockAllowList) Len() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Len")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MockAllowList_Len_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Len'
type MockAllowList_Len_Call struct {
	*mock.Call
}

// Len is a helper method to define mock.On call
func (_e *MockAllowList_Expecter) Len() *MockAllowList_Len_Call {
	return &MockAllowList_Len_Call{Call: _e.mock.On("Len")}
}

func (_c *MockAllowList_Len_Call) Run(run func()) *MockAllowList_Len_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockAllowList_Len_Call) Return(_a0 int) *MockAllowList_Len_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAllowList_Len_Call) RunAndReturn(run func() int) *MockAllowList_Len_Call {
	_c.Call.Return(run)
	return _c
}

// LimitedIterator provides a mock function with given fields: limit
func (_m *MockAllowList) LimitedIterator(limit int) AllowListIterator {
	ret := _m.Called(limit)

	if len(ret) == 0 {
		panic("no return value specified for LimitedIterator")
	}

	var r0 AllowListIterator
	if rf, ok := ret.Get(0).(func(int) AllowListIterator); ok {
		r0 = rf(limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(AllowListIterator)
		}
	}

	return r0
}

// MockAllowList_LimitedIterator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LimitedIterator'
type MockAllowList_LimitedIterator_Call struct {
	*mock.Call
}

// LimitedIterator is a helper method to define mock.On call
//   - limit int
func (_e *MockAllowList_Expecter) LimitedIterator(limit interface{}) *MockAllowList_LimitedIterator_Call {
	return &MockAllowList_LimitedIterator_Call{Call: _e.mock.On("LimitedIterator", limit)}
}

func (_c *MockAllowList_LimitedIterator_Call) Run(run func(limit int)) *MockAllowList_LimitedIterator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *MockAllowList_LimitedIterator_Call) Return(_a0 AllowListIterator) *MockAllowList_LimitedIterator_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAllowList_LimitedIterator_Call) RunAndReturn(run func(int) AllowListIterator) *MockAllowList_LimitedIterator_Call {
	_c.Call.Return(run)
	return _c
}

// Max provides a mock function with given fields:
func (_m *MockAllowList) Max() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Max")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// MockAllowList_Max_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Max'
type MockAllowList_Max_Call struct {
	*mock.Call
}

// Max is a helper method to define mock.On call
func (_e *MockAllowList_Expecter) Max() *MockAllowList_Max_Call {
	return &MockAllowList_Max_Call{Call: _e.mock.On("Max")}
}

func (_c *MockAllowList_Max_Call) Run(run func()) *MockAllowList_Max_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockAllowList_Max_Call) Return(_a0 uint64) *MockAllowList_Max_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAllowList_Max_Call) RunAndReturn(run func() uint64) *MockAllowList_Max_Call {
	_c.Call.Return(run)
	return _c
}

// Min provides a mock function with given fields:
func (_m *MockAllowList) Min() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Min")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// MockAllowList_Min_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Min'
type MockAllowList_Min_Call struct {
	*mock.Call
}

// Min is a helper method to define mock.On call
func (_e *MockAllowList_Expecter) Min() *MockAllowList_Min_Call {
	return &MockAllowList_Min_Call{Call: _e.mock.On("Min")}
}

func (_c *MockAllowList_Min_Call) Run(run func()) *MockAllowList_Min_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockAllowList_Min_Call) Return(_a0 uint64) *MockAllowList_Min_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAllowList_Min_Call) RunAndReturn(run func() uint64) *MockAllowList_Min_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function with given fields:
func (_m *MockAllowList) Size() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// MockAllowList_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type MockAllowList_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *MockAllowList_Expecter) Size() *MockAllowList_Size_Call {
	return &MockAllowList_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *MockAllowList_Size_Call) Run(run func()) *MockAllowList_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockAllowList_Size_Call) Return(_a0 uint64) *MockAllowList_Size_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAllowList_Size_Call) RunAndReturn(run func() uint64) *MockAllowList_Size_Call {
	_c.Call.Return(run)
	return _c
}

// Slice provides a mock function with given fields:
func (_m *MockAllowList) Slice() []uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Slice")
	}

	var r0 []uint64
	if rf, ok := ret.Get(0).(func() []uint64); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]uint64)
		}
	}

	return r0
}

// MockAllowList_Slice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Slice'
type MockAllowList_Slice_Call struct {
	*mock.Call
}

// Slice is a helper method to define mock.On call
func (_e *MockAllowList_Expecter) Slice() *MockAllowList_Slice_Call {
	return &MockAllowList_Slice_Call{Call: _e.mock.On("Slice")}
}

func (_c *MockAllowList_Slice_Call) Run(run func()) *MockAllowList_Slice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockAllowList_Slice_Call) Return(_a0 []uint64) *MockAllowList_Slice_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAllowList_Slice_Call) RunAndReturn(run func() []uint64) *MockAllowList_Slice_Call {
	_c.Call.Return(run)
	return _c
}

// Truncate provides a mock function with given fields: _a0
func (_m *MockAllowList) Truncate(_a0 uint64) AllowList {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Truncate")
	}

	var r0 AllowList
	if rf, ok := ret.Get(0).(func(uint64) AllowList); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(AllowList)
		}
	}

	return r0
}

// MockAllowList_Truncate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Truncate'
type MockAllowList_Truncate_Call struct {
	*mock.Call
}

// Truncate is a helper method to define mock.On call
//   - _a0 uint64
func (_e *MockAllowList_Expecter) Truncate(_a0 interface{}) *MockAllowList_Truncate_Call {
	return &MockAllowList_Truncate_Call{Call: _e.mock.On("Truncate", _a0)}
}

func (_c *MockAllowList_Truncate_Call) Run(run func(_a0 uint64)) *MockAllowList_Truncate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *MockAllowList_Truncate_Call) Return(_a0 AllowList) *MockAllowList_Truncate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAllowList_Truncate_Call) RunAndReturn(run func(uint64) AllowList) *MockAllowList_Truncate_Call {
	_c.Call.Return(run)
	return _c
}

// WrapOnWrite provides a mock function with given fields:
func (_m *MockAllowList) WrapOnWrite() AllowList {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for WrapOnWrite")
	}

	var r0 AllowList
	if rf, ok := ret.Get(0).(func() AllowList); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(AllowList)
		}
	}

	return r0
}

// MockAllowList_WrapOnWrite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WrapOnWrite'
type MockAllowList_WrapOnWrite_Call struct {
	*mock.Call
}

// WrapOnWrite is a helper method to define mock.On call
func (_e *MockAllowList_Expecter) WrapOnWrite() *MockAllowList_WrapOnWrite_Call {
	return &MockAllowList_WrapOnWrite_Call{Call: _e.mock.On("WrapOnWrite")}
}

func (_c *MockAllowList_WrapOnWrite_Call) Run(run func()) *MockAllowList_WrapOnWrite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockAllowList_WrapOnWrite_Call) Return(_a0 AllowList) *MockAllowList_WrapOnWrite_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAllowList_WrapOnWrite_Call) RunAndReturn(run func() AllowList) *MockAllowList_WrapOnWrite_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAllowList creates a new instance of MockAllowList. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAllowList(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAllowList {
	mock := &MockAllowList{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
